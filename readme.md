## Two-pass "fuzzy" transformer from Perl to "semi-Python" 
### THIS IS A PRE ANNOUNCEMENT 

Some organizations are now involved in converting their Perl codebase into Python. The author previously participated in several projects of converting mainframe codebase to Unix (mainly AIX) and think that this area might be a useful expansion of his skills. 
 
Of course, Perl 5 is here to stay (please note what happened with people who were predicting the demise of Fortran ;-), but for some reason, 
several organizations are expressed interest in converting their support script codebase into a single language. Most often, this is Python. 
Ruby, which is probably a better match for such a translation, is seldom used. 

My feeling is that there should be some better tools for this particular task to lessen the costs, time, and effort. One trivial idea is to have a better, 
whitten with some level of knowledge of compiler technologies tool that falls into the category of medium size complies with total effort around one man year or less. 

Assuming ten lines per day of debugged code for the task of complexity comparable with the writing of compilers, the estimated size should be around 3-4K lines of code. 

So far, just an idea, although the prototype was already written. It might be wrong, and it might be impossible to write anything useful in less than 4K lines. 

In any case the idea of "fuzzy pythonizer" is to translate a subset of Perl typically used in sysadmin scripts into Python, marking untranslatable statements
or statements parts with appropriate comments using a combination of two approaches approaches

1. Fuzzy matching. The program will use a database of "normalized" patterns to translate some common statements. No machine learning algorithms or God forbid neural networks will be used ;-). Some Prolog level staff at max. See also http://www.informit.com/articles/article.aspx?p=1848528
  
2. Limited lookahead "fuzzy" parsing (Maybe long forgotten Floyd-Evans language can be used; see Gries book https://www.amazon.com/Compiler-Construction-Digital-Computers-David/dp/047132776X )

Preliminary classification performed by the author and the Knuth old paper (1971)  D. Knuth. An empirical study of FORTRAN programs. Software—Practice and Experience , 1:105–133, 1971 ; ( https://www.cs.tufts.edu/~nr/cs257/archive/don-knuth/empirical-fortran.pdf ) ; the online version of Stanford research report is available at  https://apps.dtic.mil/dtic/tr/fulltext/u2/715513.pdf ) suggests that around 20-30% of statements in a typical Perl sysadmin script can be found in
the database using some form of fuzzy matching. 

Another 50% can be (perfectly of "fuzzy") translated using recursive descent parser or some limited lookahead method

Around 20% can be translated only in part (but some useful hints can be provided) 

Around 10% are non-translatable by automatic means without a huge and unjustifiable increase in the complexity of such a translator.  For example for many Perl subroutines it is impossible to guess the actual number of parameters. There can be some clues like 

```Perl
($p1,$p2,$p3)=@_;
```

or $_[0], $_[1] and $_[2] in the body of the subroutine. But that's about it. 


The most interesting part here is whether it is possible to match and mix those two parts into a usable product that has less than 4K lines of code.   

As this is a hobby project, no timeline is provided, but I expect to create an alpha version in early 2020.

The author would appreciate comments and pointers to useful information by those who are interested in the final product.  

So far, conceptually, the translator with work in two phases/passes. The first phase is the "normalization" of the Perl program to simplify the second phase. See Neatperl for some ideas used in this phaze. 

The second stage is a conversion of the reformatted and specially prepared Perl code into Python. Whether I'll need the full parse tree or not is an interesting question, but I would definitely benefit from the cross-reference table generated by the Perl interpreter beacuse print statements in Perl perform automatic convertion of variables to string, but in Python you need to specify such a convertion explisidly. That  measn that for correct translation you need to "guess" the type of variables in Perl scripts, for example numberic vs string.

A similar problem arises with comparisons which in Perl are typed and the variables are coerced into chosen type (string vs numeric comparison) but in Python are not typed and you need to ensure compatibility of operands yourself.


