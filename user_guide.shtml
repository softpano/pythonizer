<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>Pythonizer user guide</title>
<style>
body {Background-color: #FFFFFF link: #0000CC vlink: #660066} 
h1  { font-family: arial; text-align: Center; color: #CC0000 }
h2  { font-family: arial; text-align: Center; color: #0000CC }
h3  { font-family: arial; text-align: Center }
h4  { font-family: Arial;  color: #006400}
h5  { font-family: Arial;  color: #333300; font-style: italic}
h6  { font-family: Arial; font-size: 10pt; font-style: bold}
em  { font-style: italic; font-weight: bold; color: #FF0000}
cite { font-style: italic; font-weight: bold; color: blue }
a  {color: #0000FF;}

td {font-family:arial,helvetica,sans-serif; font-size:10pt;}

p.petit { font-family: arial; font-size: smaller }
table.swb    {Background-color: cyan}
td.swb       { border-right-style: solid; border-bottom-style: solid }
table.nb    {Background-color: #ffffcc}
tr.nb       { text-align: Center; font-weight: bold }
td.nb        { border-style: solid }
kbd {font-family: Fixedsys; font-size: 12pt; color: #0000FF;}
tt {font-family: Fixedsys; font-size: 12pt; color: #0000FF;}
code {font-family: Fixedsys; font-size: 12pt; color: #0000FF;}
pre {font-family: Fixedsys; color: #0000FF; font-size: 12pt; margin: 1em 40px; }
pre.code {font-family: Fixedsys; color: #0000FF; margin: 1em 40px;}
blockquote {font-size: 10pt; font-family: arial; background: #F9F9F9}
</style>
</head>

<body>

<h1>Pythonizer user guide </h1>

<h3>Version 0.82 (Oct 06, 2020)</h3>

<table border="1" width="100%" bgcolor="#FFFFCC">
   <tr>
      <td width="14%" align="center" bordercolorlight="#000000" bordercolordark="#FFFFFF"><a href="#News">News</a></td>
      <td width="14%" align="center" bordercolorlight="#000000" bordercolordark="#FFFFFF">&nbsp;<a href="../index.shtml">Python for 
      Perl programmers</a></td>
      <td width="14%" align="center" bordercolorlight="#000000" bordercolordark="#FFFFFF">

      <p align="center"><b><a href="../../../../Bookshelf/Computers/python.shtml">Best Python books for system administrators</a></b></p>
      </td>
      <td width="14%" align="center" bordercolorlight="#000000" bordercolordark="#FFFFFF"><a href="#Recommended_Links">Recommended Links</a></td>
      <td width="14%" align="center" bordercolorlight="#000000" bordercolordark="#FFFFFF"><b>
      <a href="../Pl2py_reference/pl2py_functions_map.shtml">Perl 
      to Python functions map</a></b></td>
      <td width="15%" align="center" bordercolorlight="#000000" bordercolordark="#FFFFFF"><b>
      <a href="../Py_shell_commands_execution/index.shtml">Execution of commands and shell scripts using subprocess module</a></b></td>
      <td width="15%" align="center" bordercolorlight="#000000" bordercolordark="#FFFFFF"><b>
      <a href="protocol_of_translation_of_pre_pythonizer.shtml">Full protocol of translation of pre_pythonizer.pl by the current 
      version of Pythonizer</a></b></td>
   </tr>
</table>

<p><em>NOTE: In version 0.8&nbsp; you need to specify PERL5LIB variable pointing it to the directory with modules to run the 
program. See installation section below</em></p>

<ul>

	<li><b><a href="#Introduction">Introduction</a></b></li>

    <li><b><a href="#Pre-pythonizer__implements_the_first_phase_of_translation">Pre-pythonizer&nbsp; implements the first phase of 
    translation</a></b></li>

    <li><b><a href="#Pythonizer_implements_actual_transformation_of_Perl_into_Python">Pythonizer implements actual transformation of 
    Perl into Python</a></b><ul>

	<li><b><a href="#Options">Options</a></b></li>

    <li><b><a href="#Logs">Logs</a></b></li>

    <li><b><a href="#Structure">Structure</a></b></li>

    <li><b><a href="#Installation">Installation</a></b></li>

    <li><b><a href="#Invocation">Invocation</a></b></li>

    <li><b><a href="#History">History</a></b></li>

    <li><b><a href="#Known_errors">Known errors</a></b></li>

    <li><b><a href="#Submission_of_tickets">Submission of tickets</a></b></li>

	
</ul>
    </li>

	
    <li><b><a href="#Recommended_manual_transformations_of_Perl_code">Recommended manual transformations of Perl code</a></b><ul>

	<li><a href="#Decision_to_remove_round_brackets">Decision to remove opening&nbsp; and closing round brackets
&nbsp;in Perl built-in function opened a can of worms</a></li>

    <li><a href="#Other_recommended_transformation_of_Perl_code">Other recommended transformations of Perl code</a></li>

	
</ul>
    </li>

    <li><b><a href="#Debugging_generated_Python_code">Debugging generated Python code</a></b></li>

	
</ul>
<hr noshade color="#FF0000" width="33%" size="7">

<h3><a name="Introduction">Introduction</a></h3>

<p>Some organizations are now involved in converting their old Perl codebase into other scripting languages, such as Python. But a more common task is to maintain existing 
Perl scripts, when the person who is assigned to this task known only Python. </p>

<p>University graduates now typically know Python but not Perl and that creates difficulties in the old codebase maintenance. &nbsp; 
In this case, a program that &quot;explains&quot; Perl constructs in Python term would be extremely useful and, sometimes, a lifesaver. Of 
course, Perl 5 is here to stay (please note what happened with people who were predicting the demise of Fortran ;-), and in most 
cases, old scripts will stay too.</p>

<p>The other role is to give a quick start for system administrators who want to learn Python (for example, need to support 
researchers who work with Python), but who currently knows only Perl -- many older school sysadmins dislike Python and for a reason 
;-)&nbsp;&nbsp; </p>

<p>Yes another role is provide a proof that those two languages are mostly compatible and that program from one&nbsp; can be 
translated into another with modest amount of effort. Although such translation is not necessary a best fit,&nbsp; in most cases it 
is close enough and needs just minor manual editing.&nbsp; </p>

<p>Of course, complex constructs and idioms are often translated incorrectly. Several complex issues remains unresolved (implicit 
conversion to strings in Perl is one such issues.) As experience with Google translation of natural languages attests there&nbsp; 
are always around 10 to 20% of sentences (depending of the subject area of the text)&nbsp; that are translated incorrectly. And, 
probably,&nbsp; 2-3% that have absurd or funny translation.&nbsp; </p>

<p>The idea here is that using &quot;fuzzy translation&quot; concept it is possible to create such a tool with relatively modest efforts. A tool, written with some knowledge of 
compiler technologies, that falls into the category of &quot;small language compliers&quot; with the total effort around one man-year or less. Assuming ten lines per day of debugged code for the task of complexity comparable with the writing of compilers, the estimated 
size should be around 3-5K lines of code (~1K line phase 1 and 2-3K line phase 2).</p>

<p>As of version&nbsp; 0.8 it looks like the initial idea was a sound one: within&nbsp;5K LOC limit it is possible to create a 
useful utility that transcribes Perl in Python with a decent quality. </p>

<p>As the currently code base exceeded 4K lines, it is close to the&nbsp; limit on which I can maintain this codebase as a hobby project, so 
some enhancements need to be abandoned or moved to the pre-pythonizer phase.&nbsp; This&nbsp; first of all is true about insertion 
of proper conversion of&nbsp;&nbsp; types. Right now it is left to the programmer to fix those issues.&nbsp; </p>

<p><em>NOTE: </em>Pythonizer now&nbsp; creates the list of variables that need to be declared global to preserve a part of the 
global namespace that Perl subroutines access. This is a needed function as Python has different rules of variables visibility -- 
global variables are visible in all subroutines, but to be able to modify them you need to declare them global explicitly (and this 
global variable should already exist and be initialized) </p>

<h3><a name="Installation">Installation</a></h3>

<p>For testing the main program and all modules should reside in a single directory from which you can run the program.&nbsp; </p>

<p>You need to download files or replicate the directory via git&nbsp;. Let's assume that you downloaded or replicated them into&nbsp;
<tt>/home/softpano/Pythonizer</tt><tt> </tt></p>

<p>After that you can run <tt>pythonizer</tt> from the install directory by specifying&nbsp; <tt>-I /home/softpano/Pythonizer</tt>&nbsp; option for Perl interpreter 
to point to proper directory with modules &nbsp; 
For example:</p>

<pre>perl -I /home/softpano/Pythonizer ~/Pythonizer/pythonizer script_to_be_translated.pl</pre>

<p>Alternatively you can specify PERL5LIB environment variable to point to this directory</p>
<font SIZE="3">

<pre>export PERL5LIB=<tt>/home/softpano/Pythonizer</tt></font></pre>

<p>If you already have this variable defined in your bashrc you can add this directory to the end after column, for example</p>

<pre>PERL5LIB=/home/softpano/perl5/lib/:<font SIZE="3">PERL5LIB=</font><tt>/home/softpano/Pythonizer</tt></pre>

<p>After that you do not need to use option -I of Perl interpreter and can invoke the program directly</p>

<pre>~/Pythonizer/pythonizer script_to_be_tranlated.pl</pre>

<p>In order to specify <tt>pythonizer</tt> without path you need to add the directory in which you installed it to the <tt>PATH </tt>
or copy the program to one of the directories already in <tt>PATH</tt>, for example<tt> /use/local/bin i</tt>f you are root<tt> or 
~/bin </tt>if you are a regular user<tt>.</tt></p>

<p>Version 0.8 has a simpler installer using which&nbsp; you&nbsp; can quickly move the main&nbsp; script 
and module to proper places in your directory tree. It is called <tt>installer</tt> and accept two arguments:</p>
<ul>

   <li>

   <p><b>path_to_pythonizer</b> -- directory in which you want to put <tt>pythonizer</tt> and <tt>
   pre_pythonizer.pl</tt></li>

<li>

<p><b>path_to_modules</b> -- directory in which you want to put modules (should be defined iether in <tt>@INC</tt> 
or in environment variable <tt>PERL5LIB</tt>)&nbsp; </li>
</ul>

<p>General format of invocation: </p>

<pre>installer path_to_pythonizer path_to_modules</pre>

<p>The directory&nbsp; with pythonizer and modules should be current.&nbsp; For example: </p>

<pre>cd ~/Pythonizer &amp;&amp; installer /user/local/bin /user /usr/local/share/perl5</pre>

<p>By default if run as root it assumes <tt>/usr/local/bin</tt> as the target directory for pythonizer and<tt> /usr/local/share/perl5</tt> 
for modules <p>If run as a regular user defaults are&nbsp; <tt>~/bin</tt> and <tt>~/Perl5/lib</tt>

<h3><a name="Invocation">Invocation</a></h3>

<p>You can run Pythonizer both in Cygwin and Linux. To &quot;pythonize&quot; the Perl script you need to set <font SIZE="3">
directory with modules in -I option&nbsp; of Perl interpreter, PERL5LIB, or to put modules in some directory already in @INC as 
discussed in the <a href="#Installation">Installation</a> section.</font></p>

<p>The simplest&nbsp; invocation can look like: <font SIZE="3">&nbsp;</font></p>

<pre><font SIZE="3">export PERL5LIB=</font>/opt/Pythonizer &amp;&amp; /opt/Pythonizer/pythonizer /path/to/your/program/script_to_be_translated.pl</pre>

<p>If the program runs to the end you will get &quot;pythonized&quot; text in <tt>/path/to/your/program.py</tt></p>

<p>It also produces protocol of translation in <tt>/tmp/Pythonizer</tt>&nbsp; with size by side Perl and Python code, which allows you to 
analyses the protocol detect places that need to be commented out translated 
manually. </p>

<p>If <tt>&nbsp;__DATA__</tt> or <tt>__END__</tt> are used a separate file with&nbsp; the extension&nbsp; <b>.data </b>&nbsp;(<tt>/path/to/your/program.data </tt>
for the example above) will be created with&nbsp; the content on this section of Perl script.</p>

<h3><a name="Pre-pythonizer__implements_the_first_phase_of_translation">Pre-pythonizer&nbsp; implements the first phase of 
translation</a></h3>

<p>Processing consists of two passes, which currently are not integrated in any away with <tt>pre_pythonizer</tt> mainly providing 
refactoring of Perl code to create <tt>main</tt> procedure and move all subroutines up so that they are now defined before use.&nbsp; </p>

<p>Running this phase also reformat the Perl script in a way that slightly increases chances that the script will be translated with 
fewer errors. Opening and closeting curvy bracket are put on single lines to ease the job of the lexical scanner in Pythonizer. </p>

<p>It can be used 
iether as separate utility of in integrated way via <tt>-r</tt> (<b><i>refactor</i></b>) option in pythonizer. </p>

<pre>pre_pythonizer [options] &lt;file&gt;  # currently performs is refactoring of  Perl script, 
                                 # pushing subroutines to the top and creating <tt>main</tt> sub
                                 # out of code not included  into any subroutine. 
pythonizer [options] &lt;file&gt;</pre>

<p>The first pass is currently fully optional and need transformations of Perl code can be performed by other utilities. 
It just slightly increase probability of more correct translation of the code. It reformat the code so that 
curvy brackets were mostly on separate lines (this was essential only for pythonizer up to version 0.2; later versions&nbsp;do not depend 
directly on this transformation.) </p>

<p>It can be used as a separate program, which transforms initial Perl script creating a backup with the extension <tt>.original.</tt> 
The main useful function in the current version is refactoring of the Perl program by pushing subroutines up as in Python 
subroutines needs to be declared before use. </p>

<p>It needs to run only once for each Perl script you want to translate to Python. Subsequence modifications of Perl script to make 
it more &quot;Python-compatible&quot; can be performed on this text instead of the original script. </p>

<h3><a name="Pythonizer_implements_actual_transformation_of_Perl_into_Python">Pythonizer implements actual transformation of Perl 
into Python</a></h3>

<p>Running&nbsp; <tt>pythonizer -h</tt> provides a&nbsp; list of options. </p>

<p>Here is example of the protocol&nbsp;
<a href="protocol_of_translation_of_pre_pythonizer020.shtml">Full protocol of translation of pre_pythonizer.pl by version 0.2 of 
pythonizer</a></p>

<p>To increase chances of correct translation it is recommended to run the Perl script via
<span>
<a title="pre_pythonizer.pl" id="9413911e31717187d3a97255af3e0f95-f911160659ba8e3129cfb73f329fb2fd14950434" href="https://github.com/softpano/pythonizer/blob/master/pre_pythonizer.pl">
pre_pythonizer.pl</a></span></p>

<p><span>Parts that can't be translated during the first invocation can 
be commented outs and iteratively you can modify simplify Perl code and reach the stage when the Perl script is translated more or 
less OK. After that you can work in Python debugger and iron remaining inconsistencies and cases of incorrect translation of 
statements. Sometimes algorithm of a part of the program need to be adapted to Python.&nbsp; </span></p>

<p><b><span>Some features:</span></b></p>

<ul>

   <li>The Pythonizer is implemented in Perl 5.10+ and does not use any non standard Perl libraries. </li>

   <li>Converts most of Perl 5 code typical for sysadmin scripts into Python. That includes loops, special variables, function 
   calls, lists, hashes,&nbsp; etc.</li>

   <li>Recognizes some Perl idioms and special cases. Perform limited peephole optimization of Perl within individual statements in case this is possible (for example use 
   of replace function&nbsp; instead or regular expression in&nbsp; case both the source and target are plain strings. it also optimize some types of split function when the regex supplied to Perl actually is a string and does not contain any 
   metacharacters. </li>

   <li>Whenever there is no equivalent Python function for a Perl function, the function is emulated. Currently this is done only in 
   cases when this does not require additional Python library.</li>

   <li>Perl special variables are renamed to selected Python names and used consistently. But that does not mean that they are 
   correctly populated. </li>

   <li>Limited translation of double quoted literals with scalars inside list elements and hash elements and ‘here-documents’ is 
   supported. Most common special variable are also translated to their equivalents in double quoted operators. </li>

   <li>Arguments to Perl subroutines are emulated via lists</li>

   <li>In case of Perl control constructs that are missing in Python (for example <tt>(debug&gt;0) &amp;&amp; say $line</tt>; or <tt>open(SYSIN,'&lt;',',$mytext) 
   || die(&quot;Can't open the file $mytest\n&quot;);<span lang="ru">) </tt></span>they are translated into equivalent Python 
   constructs. There are some exceptions, for example Perl <tt>continue</tt> statement, but they are rarely used. </li>

   <li>Tail data after <tt>__DATA__</tt> or <tt>__END__ </tt>&nbsp;are converted to a separate file with the same name as script and<tt> 
   .data</tt></li>

   <li>List of statements for which pythonizer encountered difficulties and most probably did not translate correctly are produced 
   at the end. </li>
</ul>

<h4><a name="Limitations">Limitations</a></h4>
<ul>

   <li>No OO constructs&nbsp; such as <tt>bless</tt> and <tt>package</tt> statement are translated.&nbsp; The <tt>use</tt> statement and import 
   and expert of variables from modules also need to be translated manually.&nbsp; </li>

   <li>The content of&nbsp; ‘BEGIN’, ‘END’ blocks is translated but blocks itself need to be emulated manually.&nbsp; Please note 
   that these blocks are executed at the time of execution of Perl interpreter, not at the time of execution of&nbsp; the script, so 
   opportunities to match Perl semantic here are limited.&nbsp; </li>

   <li>References are not translated correctly. In many cases of usage of references in Perl this is very difficult to&nbsp; express 
   in Python </li>
</ul>

<h3><a name="Options">Options</a></h3>

<p><em>NOTE: </em>All options with small numeric values can be expressed by&nbsp; repeating the letter, so<tt> -p 2</tt> is equivalent to <tt>-pp.</tt> 
<tt>-d 3 -ddd</tt></p>

<p>Currently only few user options are supported (<tt>pythonizer -h</tt> provides a&nbsp; list of options):&nbsp; </p>
<ul>

   <li><tt>-p</tt> -- The version of Python used for generation. Default is 3.8 (can be set explicitly by specifying <tt>-p 3</tt>) 
   You can set 2.7 by using&nbsp; <tt>-p 2</tt></li>

   <li><tt>-v</tt> -- verbosity <tt>-v 0</tt> -minimal verbosity <tt>-v 3</tt> -- max verbosity; can also be expresses as <tt>-v <tt>
   </tt>-vv</tt> and <tt>-vvv </tt>-- forms to which Unix user got used in other utilities</li>

   <li><tt>-t</tt>&nbsp; -- tab size for generated code; the default<tt> -t 4</tt> </li>

   <li><tt>-r</tt> -- refactor Perl code. If specified, before processing the script by the pythonizer, it&nbsp; invokes the <tt>
   pre_pythonizer</tt> 
   preliminary pass on the source code. Of course this can be&nbsp; done manually 
   with&nbsp; more control but this provides an integrated way to refactor the program. </li>
</ul>

<p><b>Options for developers</b></p>

<ul>

   <li><tt>-d</tt> -- debug option <em>for developers</em>; default<tt> -d 0</tt> </li>

   <li><tt>-b</tt> -- breakpoint option<em> for developers</em>; default <tt>-b 99999</tt></li>
</ul>

<p>The same options work for the <tt>pre_pythonizer</tt>, but usually defaults are OK.&nbsp; There is no options to control 
refactoring of the script. </p>

<h3><a name="Logs">Logs</a></h3>

<p>Logs are written to <tt>/tmp/Pythonizer&nbsp; </tt>You can redirect this to any directory via symlink.<tt> </tt>
Currently there is no option to customize the location of the log. </p>

<h3><a name="Structure">Structure</a></h3>

<p>Pythonizer consists of the main program called, as you can guess, <tt>pythonizer</tt> and three modules (which currently need to 
reside in the same directory as the main program. Main program currently used three modules, which should be located so that the 
main program can load then from @INC array set of directories: </p>
<ul>

   <li><tt>Perlscan.pm</tt></li>

   <li><tt>Pythonizer.pm</tt></li>

   <li><tt>Softpano.pm</tt></li>

</ul>

<p>The total size of the codebase in version 0.8 is around 4.3K lines: </p>
<pre>
# wc -l Perlscan.pm Pythonizer.pm  pythonizer  Softpano.pm pre_pythonizer.pl
  1119 Perlscan.pm
   465 Pythonizer.pm
  1577 pythonizer
   339 Softpano.pm
   825 pre_pythonizer.pl
  4325 total</pre><p>The total size of the codebase in version 0.6 is slightly over 4K lines: 
</p>
<pre>
wc -l Perlscan.pm Pythonizer.pm  pythonizer  Softpano.pm pre_pythonizer.pl
  1107 Perlscan.pm
   382 Pythonizer.pm
  1515 pythonizer
   339 Softpano.pm
   825 pre_pythonizer.pl
  4168 total</pre>
<p>The total size of the codebase in version 0.5 is slightly below 4K lines: 
</p>
<pre>
wc -l Perlscan.pm Pythonizer.pm  pythonizer  Softpano.pm pre_pythonizer.pl
  1051 Perlscan.pm
   317 Pythonizer.pm
  1442 pythonizer
   336 Softpano.pm
   825 pre_pythonizer.pl
  3971 total</pre>

<p>The total size of the codebase in version 0.4 is around 3.5K lines: </p>

<pre>wc -l Perlscan.pm Pythonizer.pm  pythonizer  Softpano.pm pre_pythonizer.pl
   866 Perlscan.pm
   292 Pythonizer.pm
  1268 pythonizer
   312 Softpano.pm
   833 pre_pythonizer.pl
  3571 total</pre>

<h3><a name="Recommended_manual_transformations_of_Perl_code">Recommended manual transformations of Perl code</a></h3>

<p>The first and foremost under-parenthesised Perl script (the scripts which uses built in function without parenthesis, like 
recommended by &quot;Modern Perl&quot; are translated with more errors by the current version of Pythonizer. </p>

<p>Also some complex expressions need to be factored out to get correct translation. But this is to be expected due to limitation of 
the size and the complexity of this project. </p>

<p>Recently Perl adopted Python stance of minimizing the number of parenthesis is different topic that is discussed below </p>

<p>But simply adding parenthesis in cases Pythonizer complains in most cases allow the correct translation. </p>

<p>Generally, Perl provide too much syntax rope and some programmers manage to hang themselves with it: the syntax variety allowed is just an 
overkill and stimulate adoption of &quot;perverted&quot; constructs which detract from, not add to the clarity of the code.&nbsp;&nbsp; </p>

<p>The most typical 
example is an excessive use of postfix if constructs. I would understand using them in loop to specify exist condition like </p>
<blockquote>

   <pre>last if (substr($line,0,3) eq 'EOF');</pre>
</blockquote>

<p>but not like </p>
<blockquote>

   <pre>x++ if $i&lt;$limit;</pre>
</blockquote>

<p>in this case writing</p>
<blockquote>

   <pre>if ( $i &lt; $limit ) { $x++; }</pre>
</blockquote>

<p>is only two symbols longer but is much clearer and modifiable.&nbsp; Pythonizer recognizes single statements with postfix if or 
other conditional modifiers, but not</p>
<blockquote>

   <pre>{Block} if(EXPR);</pre>
</blockquote>

<p>But even in case </p>

<pre class="code">$i=5,$j=10 if( $next iteration);</pre>

<p>IMHO provides way too much syntax flexibility ;-).You need to transform your such statements to prefix if statements if you want automatic 
translation.&nbsp;&nbsp; Actually the result looks more readable</p>

<pre>if( $next iteration ){
   $i=5;$j=10
}</pre>

<h3><a name="Decision_to_remove_round_brackets">Decision to remove opening&nbsp; and closing round brackets<br>
&nbsp;in Perl built-in function opened a can of worms</a></h3>

<p>Situation with under-parenthesized built-in function, that is mentions above,&nbsp; is more complex and here I think Perl implementers made a blunder opening a can of 
worms. Many statements written in this fashion are ambiguous. </p>

<p>So we will have problems independently of the level of the complexity allowed in Pythonizer. </p>

<p>For example:</p>
<blockquote>
   It looks like with parenthesis elimination drive Perl developers&nbsp; into the situation similar to Chinese situation with the 
   elimination of sparrows.<p>Today I encountered the following ambiguous statement written in &quot;de-parenthesized&quot; &quot;Modern Perl&quot;:</p>

   <pre>get_config(split /$s/,$_);</pre>

   <p><a href="https://perlmonks.org/?abspart=1;displaytype=displaycode;part=1;node_id=11122556">[download]</a></p>

   <p>Where it is completely unclear if</p>

   <ol>

      <li>We have two arguments to <tt>get_config</tt> and one argument to <tt>split</tt>&nbsp;(regular expression &lt;tt&gt;/$s/&lt;tt&gt;, 
      and split is assumed to be operating on $_) </li>

      <li>We have two arguments <tt>to split (/$s/ </tt>and<tt> $_ )</tt>&nbsp;and one argument (expression) to <tt>get_config</tt>. 
   
      </li>
   </ol>
   
   <p>It is accepted by interpreter as case (2) which 
   IMHO is correct, but still pretty arbitrary, especially if you write
<pre>get_config(split /$s/,$i)</pre>
<p>instead.</p>

   <pre>
   DB&lt;100&gt; sub get_config{ print scalar(@_), join(' ',@_),&quot;\n&quot;} 
   DB&lt;101&gt; $s=' '; 
   DB&lt;102&gt; $_=qq(abba baba); 
   DB&lt;103&gt; get_config(split /$s/,$_); 
   2abba baba</pre>

   <blockquote>
      <blockquote>

         <p><a href="https://perlmonks.org/?abspart=1;displaytype=displaycode;part=7;node_id=11122556">[download]</a></p>
      </blockquote>
   </blockquote>

  

   <p>Unless this problem is fixed, this is an argument for sticking to earlier versions of Perl 5 and avoiding &quot;de-parenthesized&quot; 
   &quot;Modern Perl&quot;. Looks like &quot;Parenthesis eliminators&quot; essentially harmed the language, while trying to help. That's happens, but 
   this is a rather sad situation.</p>

   <p>In any case, versions after 5.26 probably will reach commercial Linuxes in 5 to 10 years time-frame so there is still a time 
   to fix this.</p>
</blockquote>

<h3><a name="Other_recommended_transformation_of_Perl_code">Other recommended transformations of Perl code</a></h3>

<p>While parenthesizing built-in function in statements which caused problems for Pythonizer is number one recommendation, there are 
several other. </p>

<p>In many case you can get more correct translation via Pythonizer by simplifying Perl code. Some transformation can be done via macro generator like 
M4 some via Perl itself using regular expressions.</p>

<p>If pre-pythonizer transformation of Perl code produces errors you need to fix them before submitting 
the code to pythonizer.</p>

<p>Pythonizer expects syntaxically correct Perl code. &nbsp; </p>

<p>If it hangs or goes into infinite loop, then you need to comments out the offending line(s) and try again. You can use option -d 
3 to find the line if it is not clear from the listing. </p>

<p>Also old <tt>open </tt>statement where the <i><b>opening&nbsp; mode</b></i> is prefixed to the file is better converted to 
the new mode when it is a separate argument as not all modes are correctly recognized in the old format. </p>

<p>Excessive syntax flexibility might helps to explains flimsy error reporting by Perl interpreter, when it accepts clearly 
syntaxically incorrect programs as valid. Version 5.26.3 also refuse to function properly in some cases, but recovers if you change 
your Perl code a little bit. I experienced one such situation with <tt>pythonizer</tt>, when I thought that it might be better to 
switch to GOlang. </p>

<p><em>NOTE:</em> To increase changes of success in translation of long scripts you can split your code into several chunks (for example main program and subs) and try to convert 
them chunk by chunk. Then you can merge the code and add global declarations manually. </p>

<h3><a name="Debugging_generated_Python_code">Debugging generated Python code</a></h3>

<p>Python debugger is still inferior to Perl debugger, so working with it is more difficult and time consuming.&nbsp; </p>

<p>The standard invocation is something like </p><font SIZE="3">

<pre>python3.8 -m pdb maintest.py</pre>
</font>

<p>You can run the script till the first error with the command 'c' and if you are lucky at this point you have some useful 
information what&nbsp; is wrong from the diagnostic message produced by Python interpreter. If not, you need to work step by step 
and determine the context of the error yourself </p>

<p>See&nbsp; <a href="../../Debugging/index.shtml">Python Debugging</a> for some additional information and tips. </p>

<p>Generally to find the fist error you can run&nbsp; the generated code&nbsp; with the command c and proceed from this point. </p>

<p>But the fact that code runs to this point does not mean that the code executed correctly: you need to verify that. </p>

<p>For some additional ideas see <a href="../translating_perl_to_python.shtml">Perl to Python translation</a></p>
<blockquote>

   <h3><a name="Known_errors">Known errors</a></h3>
</blockquote>

<ol>

   <li>Pythonizer does not like statements with omitted round brackets and can mark then untranslatable, while translating them correctly if 
brackets are added. </li>

   <li>For long scripts to increase changes of success you can split your code into several chunks (for example main program and subs) 
and try to convert them chunk by chunk. </li>

   <li>In version 0.8 filehandles are not included in the list of global variables and as such are not propagated correctly of file 
operations on a given file handle spread into several different subroutines. </li>

   <li>State variable are now simply mapped to global namespace which can create conflicts and corrupt their value at run time.&nbsp; So 
the usage of state variable currently needs to ne manually reviewed to detect such conflicts. They are rare but they happen.&nbsp; One possible solutions to rename them using sub name as the prefix. For example in sub 
   <tt>maxi</tt> the state variable <tt>limit</tt> 
can be renamed into <tt>maxi_limit</tt></li>
</ol>

<h3><a name="Submission_of_tickets">Submission of tickets</a></h3>

<p>Tickets can be opened on GitHub. </p>

<p>The ticket should be reproducible on the most recent uploaded version; non reproducible tickets related to earlier version will be ignored.&nbsp; 
Information proved should be enough to reproduce the error: </p>

<ul>

   <li>If case of internal errors, for example rejection of a valid statement, incorrect translation,&nbsp; or unlimited recursion please provide the current line and the context (say 
   10&nbsp; &quot;before&quot; and 10 &quot;after&quot; lines.) </li>
</ul>

<p>It is recommended that you run pythonizer with the debugging option <tt>-d 3</tt> to generate additional output relevant fragment 
(only relevant fragment) can be attaches as a file to the ticket.</p>

<p>Samples the cause internal errors also need to be attached as files to save my time.&nbsp; </p>



<h3><a name="History">History</a></h3>


   <p><b>Version 0.8 uploaded</b></p>
   <blockquote>

      <p><b>Changes since version 0.7 </b></p>

      <p>More correct translation of array assignments. Some non-obvious bugs in translation were fixed. Now you need to specify 
      PERL5LIB variable pointing it to the directory with modules to run the program. Global variable now are initialized after main sub to undef value 
      to create a global namespace. Previously this was done incorrectly.&nbsp; Simple installer for Python programmers who do not 
      know much Perl added: the problem proved to be useful as a help for understanding Perl scripts by Python programmers. </p>

      <p><b>Changes in pre_pythonizer.pl</b></p>

      <p>Unlike previous versions,&nbsp; the current version by default <em>does not create</em> <tt>main</tt> <em>subroutine out of statement found on nesting level 
      zero</em>, as it introduces some errors. You need specify option <tt>-m</tt> to create it. </p>

      <p><em>NOTE:</em> All Python statements on nesting level zero should starts from the beginning of the line which is ugly, but 
      you can enclose them in the dummy <tt>if</tt> statement </p>

      <pre>if True: </pre>

      <p>to create the artificial nesting level 1</p>
   </blockquote>

   <p><b>Version 0.7 uploaded</b></p>
   <blockquote>

      <p><b>Changes since version 0.6. </b></p>

      <p>This version creates of the list of global variables for each subroutine to maintain the same visibility in Python as in 
      Perl and generates <tt>global</tt> statement with the list of such&nbsp; variables that is inserted in each Python subroutine 
      definition if pythonizer determined that this subroutine access global variables. The list might be excessive. </p>
   </blockquote>

   <p><b>Version 0.6 uploaded</b></p>
   <blockquote>

      <p><b>Changes since version 0.5. </b></p>

      <p>Regular expressions now are translated more&nbsp; correctly. Short cut if like <tt>(debug&gt;0) &amp;&amp; say $line</tt> are translated 
   in more general way then before.&nbsp; This is the first version that translates the main test (<tt>pre_pythonizer.pl</tt>) without syntax 
      errors.&nbsp;&nbsp; Generated source&nbsp; starts executing in Python interpreter till the first error. List on internal 
      functions created. Translation of backquotes and open statement improved. </p>
   </blockquote>

   <p><b>Version 0.5 uploaded</b></p>
   <blockquote>

      <p><b>Changes since version 0.4</b></p>

      <p>
      <span>Regular 
   expression and tr function translation was improved. Many other changes and error corrections. -r (refactor) option implemented to 
   allow refactoring Perl source via pre-pythonlizer.pl in integrated fashion.</span></p>
   </blockquote>

   <p><b>Version 0.4 uploaded</b></p>
   <blockquote>

      <p><b>Changes&nbsp; since version 0.3</b></p>
   </blockquote>
   <ul>

      <li>Scanner is improved</li>

      <li>f-strings are now generated for double quoted literals</li>

      <li>Many errors fixed. </li>
   </ul>

   <p><b>Version 0.3 uploaded</b></p>
   <blockquote>

      <p><b>Changes since version 0.2: </b></p>
   </blockquote>
   <ul>

      <li>default version of Python used is now version 3.8; </li>

      <li>option -p 
allows to set version 2 id you still need generation for Python 2.7 (more constructs will be untranslatable). </li>
   </ul>
</blockquote>

<hr>
<!--#include virtual="/adv_news_pane.htm" -->
<hr>
<h2><a name="News">Old News</a> ;-) </h2>

   <h4>[Oct 05, 2020] <a href="https://github.com/softpano/pythonizer">Version&nbsp; 0.8 uploaded</a> </h4>
   <blockquote>

      <p><b>Changes since version 0.7 </b></p>

      <p>More correct translation of array assignments. Some non-obvious bugs in translation were fixed. Now you need to specify 
      <tt>PERL5LIB</tt> variable pointing it to the directory with modules to run the program. Global variable now are initialized after main sub to undef value 
      to create a global namespace. Previously this was done incorrectly.&nbsp; Simple installer for Python programmers who do not 
      know much Perl added: the problem proved to be useful as a help for understanding Perl scripts by Python programmers. </p>

      <p><b>Changes in pre_pythonizer.pl</b></p>

      <p>Current version by default <em>does not create</em> <tt>main</tt> <em>subroutine out of statement found on nesting level 
      zero</em>, as it introduces some errors. You need specify option <tt>-m</tt> to create it. </p>

      <p><em>NOTE:</em> All Python statements on nesting level zero should starts from the beginning of the line which is ugly, but 
      you can enclose them in the dummy <tt>if</tt> statement </p>

      <pre>if True: </pre>

      <p>to create artificial nesting level 1</p>
   </blockquote>

   <h4>[Sep 18, 2020] <a href="https://github.com/softpano/pythonizer">Version&nbsp; 0.7 uploaded</a> </h4>
<blockquote>

   <p><b>Changes since version 0.6</b></p>

   <p>This version creates of the list of global variables for each subroutine to maintain the same visibility in Python as in Perl 
   and generates <tt>global</tt> statement with the list of such&nbsp; variables that is inserted in each Python subroutine 
   definition if pythonizer determined that this subroutine access global variables. </p>

   <p>So far the specifics of Perl <tt>state</tt> variable is ignored and they are assumed to be yet another type of global 
   variables (they generally do not belong to the global namespace as while they have lifetime similar to global variables their 
   namespace is local). </p>
</blockquote>

<h4>[Sep 08, 2020] <a href="https://github.com/softpano/pythonizer">Version 0.6 uploaded</a></h4>
<blockquote>

   <p>Regular expressions now are translated more&nbsp; correctly. Short cut if like <tt>(debug&gt;0) &amp;&amp; say $line</tt> are translated 
   in more general way then before.&nbsp; This is the first version that translates the main test (pre_pythonizer.pl) without syntax 
   errors. Generated source&nbsp; starts executing in Python interpreter till the first error. List on internal functions created. 
   Translation of backquotes and open statement improved. </p>
</blockquote>

<h4>[Aug 31, 2020] <a href="https://github.com/softpano/pythonizer">Version 0.5 uploaded</a></h4>

   <blockquote>

      <p><b>Changes since version 0.4</b></p>
      <ul>

         <li>
         <span>Regular 
   expression and tr function translation was improved. </span></li>

         <li>
         <span>
         Many</span><span> other changes and error corrections. 
         </span></li>

         <li>
         <span>-r (refactor) option implemented to 
   allow refactoring Perl source via pre-pythonlizer.pl in integrated fashion.</span></li>
      </ul>
</blockquote>

<h4><b>[Aug 22, 2020] <a href="https://github.com/softpano/pythonizer">Version 0.4 uploaded</a></b></h4>
<blockquote>

   <p><b>Changes&nbsp; since version 0.3</b></p>
   <ul>

      <li>Lexical scanner improved</li>

      <li>f-strings are now generated for double quoted literals</li>

      <li>Many errors fixed. </li>
   </ul>
</blockquote>

<h4>[Aug 17, 2020] <a href="https://github.com/softpano/pythonizer">Version 0.3 was uploaded</a> </h4>
<blockquote>

   <p><b>Changes since version 0.2: </b> </p>
   <ul>

      <li>default version of Python used is now version 3.8; </li>

      <li>option -p 
allows to set version 2 id you still need generation for Python 2.7 (more constructs will be untranslatable). </li>
   </ul>
</blockquote>

<h2><a name="Recommended_Links">Recommended Links</a></h2>
<h3><a name="Top_articles">Top articles</a></h3>
<h3><a name="Sites">Sites</a></h3>

<ul>

   <li><a href="../../Debugging/index.shtml">Python Debugging</a></li>

   <li><a href="http://www.softpanorama.org/Scripting/Pythonorama/Python_for_perl_programmers/index.shtml">Python for Perl programmers</a></li>

   <li><a href="protocol_of_translation_of_pre_pythonizer020.shtml">Full protocol of translation of pre_pythonizer.pl </a></li>

   <li><a href="http://pleac.sourceforge.net/">PLEAC - Programming Language Examples Alike Cookbook</a></li>

   <li><a href="https://wiki.python.org/moin/PyPerlish">PyPerlish - Python Wiki</a> (it looks like the library itself is no longer 
   available, only docs survived</li>
</ul>

</body>

</html>